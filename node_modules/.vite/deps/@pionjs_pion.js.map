{
  "version": 3,
  "sources": ["../../@pionjs/pion/lib/interface.js", "../../@pionjs/pion/lib/symbols.js", "../../@pionjs/pion/lib/state.js", "../../@pionjs/pion/lib/scheduler.js", "../../@pionjs/pion/lib/util.js", "../../@pionjs/pion/lib/component.js", "../../@pionjs/pion/lib/hook.js", "../../@pionjs/pion/lib/create-effect.js", "../../@pionjs/pion/lib/use-effect.js", "../../@pionjs/pion/lib/use-context.js", "../../@pionjs/pion/lib/create-context.js", "../../@pionjs/pion/lib/use-memo.js", "../../@pionjs/pion/lib/use-callback.js", "../../@pionjs/pion/lib/use-layout-effect.js", "../../@pionjs/pion/lib/use-state.js", "../../@pionjs/pion/lib/use-reducer.js", "../../@pionjs/pion/lib/use-property.js", "../../@pionjs/pion/lib/use-ref.js", "../../@pionjs/pion/lib/core.js", "../../lit-html/src/directive.ts", "../../lit-html/src/directive-helpers.ts", "../../lit-html/src/async-directive.ts", "../../@pionjs/pion/lib/virtual.js", "../../@pionjs/pion/lib/lit-haunted.js"],
  "sourcesContent": ["let current;\nlet currentId = 0;\nfunction setCurrent(state) {\n    current = state;\n}\nfunction clear() {\n    current = null;\n    currentId = 0;\n}\nfunction notify() {\n    return currentId++;\n}\nexport { clear, current, setCurrent, notify };\n", "const phaseSymbol = Symbol(\"haunted.phase\");\nconst hookSymbol = Symbol(\"haunted.hook\");\nconst updateSymbol = Symbol(\"haunted.update\");\nconst commitSymbol = Symbol(\"haunted.commit\");\nconst effectsSymbol = Symbol(\"haunted.effects\");\nconst layoutEffectsSymbol = Symbol(\"haunted.layoutEffects\");\nconst contextEvent = \"haunted.context\";\nexport { phaseSymbol, hookSymbol, updateSymbol, commitSymbol, effectsSymbol, layoutEffectsSymbol, contextEvent, };\n", "import { setCurrent, clear } from \"./interface\";\nimport { hookSymbol, effectsSymbol, layoutEffectsSymbol, } from \"./symbols\";\nclass State {\n    update;\n    host;\n    virtual;\n    [hookSymbol];\n    [effectsSymbol];\n    [layoutEffectsSymbol];\n    constructor(update, host) {\n        this.update = update;\n        this.host = host;\n        this[hookSymbol] = new Map();\n        this[effectsSymbol] = [];\n        this[layoutEffectsSymbol] = [];\n    }\n    run(cb) {\n        setCurrent(this);\n        let res = cb();\n        clear();\n        return res;\n    }\n    _runEffects(phase) {\n        let effects = this[phase];\n        setCurrent(this);\n        for (let effect of effects) {\n            effect.call(this);\n        }\n        clear();\n    }\n    runEffects() {\n        this._runEffects(effectsSymbol);\n    }\n    runLayoutEffects() {\n        this._runEffects(layoutEffectsSymbol);\n    }\n    teardown() {\n        let hooks = this[hookSymbol];\n        hooks.forEach((hook) => {\n            if (typeof hook.teardown === \"function\") {\n                hook.teardown(true);\n            }\n        });\n    }\n}\nexport { State };\n", "import { State } from \"./state\";\nimport { commitSymbol, phaseSymbol, updateSymbol, effectsSymbol, layoutEffectsSymbol, } from \"./symbols\";\nconst defer = Promise.resolve().then.bind(Promise.resolve());\nfunction runner() {\n    let tasks = [];\n    let id;\n    function runTasks() {\n        id = null;\n        let t = tasks;\n        tasks = [];\n        for (var i = 0, len = t.length; i < len; i++) {\n            t[i]();\n        }\n    }\n    return function (task) {\n        tasks.push(task);\n        if (id == null) {\n            id = defer(runTasks);\n        }\n    };\n}\nconst read = runner();\nconst write = runner();\nclass BaseScheduler {\n    renderer;\n    host;\n    state;\n    [phaseSymbol];\n    _updateQueued;\n    _active;\n    constructor(renderer, host) {\n        this.renderer = renderer;\n        this.host = host;\n        this.state = new State(this.update.bind(this), host);\n        this[phaseSymbol] = null;\n        this._updateQueued = false;\n        this._active = true;\n    }\n    update() {\n        if (!this._active)\n            return;\n        if (this._updateQueued)\n            return;\n        read(() => {\n            let result = this.handlePhase(updateSymbol);\n            write(() => {\n                this.handlePhase(commitSymbol, result);\n                write(() => {\n                    this.handlePhase(effectsSymbol);\n                });\n            });\n            this._updateQueued = false;\n        });\n        this._updateQueued = true;\n    }\n    handlePhase(phase, arg) {\n        this[phaseSymbol] = phase;\n        switch (phase) {\n            case commitSymbol:\n                this.commit(arg);\n                this.runEffects(layoutEffectsSymbol);\n                return;\n            case updateSymbol:\n                return this.render();\n            case effectsSymbol:\n                return this.runEffects(effectsSymbol);\n        }\n    }\n    render() {\n        return this.state.run(() => this.renderer.call(this.host, this.host));\n    }\n    runEffects(phase) {\n        this.state._runEffects(phase);\n    }\n    teardown() {\n        this.state.teardown();\n    }\n    pause() {\n        this._active = false;\n    }\n    resume() {\n        this._active = true;\n    }\n}\nexport { BaseScheduler };\n", "export const sheet = (...styles) => {\n    const cs = new CSSStyleSheet();\n    cs.replaceSync(styles.join(\"\"));\n    return cs;\n};\nexport const sheets = (styleSheets) => styleSheets?.map((style) => {\n    if (typeof style === \"string\")\n        return sheet(style);\n    return style;\n});\nexport const tagged = (strings, ...values) => strings.flatMap((s, i) => [s, values[i] || \"\"]).join(\"\");\nexport const css = tagged;\n", "import { BaseScheduler } from \"./scheduler\";\nimport { sheets } from \"./util\";\nconst toCamelCase = (val = \"\") => val.replace(/-+([a-z])?/g, (_, char) => (char ? char.toUpperCase() : \"\"));\nfunction makeComponent(render) {\n    class Scheduler extends BaseScheduler {\n        frag;\n        renderResult;\n        constructor(renderer, frag, host) {\n            super(renderer, (host || frag));\n            this.frag = frag;\n        }\n        commit(result) {\n            this.renderResult = render(result, this.frag);\n        }\n    }\n    function component(renderer, baseElementOrOptions, options) {\n        const BaseElement = (options || baseElementOrOptions || {}).baseElement ||\n            HTMLElement;\n        const { observedAttributes = [], useShadowDOM = true, shadowRootInit = {}, styleSheets: _styleSheets, } = options || baseElementOrOptions || {};\n        const styleSheets = sheets(renderer.styleSheets || _styleSheets);\n        class Element extends BaseElement {\n            _scheduler;\n            static get observedAttributes() {\n                return renderer.observedAttributes || observedAttributes || [];\n            }\n            constructor() {\n                super();\n                if (useShadowDOM === false) {\n                    this._scheduler = new Scheduler(renderer, this);\n                }\n                else {\n                    const shadowRoot = this.attachShadow({\n                        mode: \"open\",\n                        ...shadowRootInit,\n                    });\n                    if (styleSheets)\n                        shadowRoot.adoptedStyleSheets = styleSheets;\n                    this._scheduler = new Scheduler(renderer, shadowRoot, this);\n                }\n            }\n            connectedCallback() {\n                this._scheduler.resume();\n                this._scheduler.update();\n                this._scheduler.renderResult?.setConnected(true);\n            }\n            disconnectedCallback() {\n                this._scheduler.pause();\n                this._scheduler.teardown();\n                this._scheduler.renderResult?.setConnected(false);\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                if (oldValue === newValue) {\n                    return;\n                }\n                let val = newValue === \"\" ? true : newValue;\n                Reflect.set(this, toCamelCase(name), val);\n            }\n        }\n        function reflectiveProp(initialValue) {\n            let value = initialValue;\n            let isSetup = false;\n            return Object.freeze({\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return value;\n                },\n                set(newValue) {\n                    // Avoid scheduling update when prop value hasn't changed\n                    if (isSetup && value === newValue)\n                        return;\n                    isSetup = true;\n                    value = newValue;\n                    if (this._scheduler) {\n                        this._scheduler.update();\n                    }\n                },\n            });\n        }\n        const proto = new Proxy(BaseElement.prototype, {\n            getPrototypeOf(target) {\n                return target;\n            },\n            set(target, key, value, receiver) {\n                let desc;\n                if (key in target) {\n                    desc = Object.getOwnPropertyDescriptor(target, key);\n                    if (desc && desc.set) {\n                        desc.set.call(receiver, value);\n                        return true;\n                    }\n                    Reflect.set(target, key, value, receiver);\n                    return true;\n                }\n                if (typeof key === \"symbol\" || key[0] === \"_\") {\n                    desc = {\n                        enumerable: true,\n                        configurable: true,\n                        writable: true,\n                        value,\n                    };\n                }\n                else {\n                    desc = reflectiveProp(value);\n                }\n                Object.defineProperty(receiver, key, desc);\n                if (desc.set) {\n                    desc.set.call(receiver, value);\n                }\n                return true;\n            },\n        });\n        Object.setPrototypeOf(Element.prototype, proto);\n        return Element;\n    }\n    return component;\n}\nexport { makeComponent, };\n", "import { current, notify } from \"./interface\";\nimport { hookSymbol } from \"./symbols\";\nclass Hook {\n    id;\n    state;\n    constructor(id, state) {\n        this.id = id;\n        this.state = state;\n    }\n}\nfunction use(Hook, ...args) {\n    let id = notify();\n    let hooks = current[hookSymbol];\n    let hook = hooks.get(id);\n    if (!hook) {\n        hook = new Hook(id, current, ...args);\n        hooks.set(id, hook);\n    }\n    return hook.update(...args);\n}\nfunction hook(Hook) {\n    return use.bind(null, Hook);\n}\nexport { hook, Hook };\n", "import { Hook, hook } from \"./hook\";\nfunction createEffect(setEffects) {\n    return hook(class extends Hook {\n        callback;\n        lastValues;\n        values;\n        _teardown;\n        constructor(id, state, ignored1, ignored2) {\n            super(id, state);\n            setEffects(state, this);\n        }\n        update(callback, values) {\n            this.callback = callback;\n            this.values = values;\n        }\n        call() {\n            const hasChanged = !this.values || this.hasChanged();\n            this.lastValues = this.values;\n            if (hasChanged) {\n                this.run();\n            }\n        }\n        run() {\n            this.teardown();\n            this._teardown = this.callback.call(this.state);\n        }\n        teardown(disconnected) {\n            if (typeof this._teardown === \"function\") {\n                this._teardown();\n                // ensure effect is not torn down multiple times\n                this._teardown = undefined;\n            }\n            // reset to pristine state when element is disconnected\n            if (disconnected) {\n                this.lastValues = this.values = undefined;\n            }\n        }\n        hasChanged() {\n            return (!this.lastValues ||\n                this.values.some((value, i) => this.lastValues[i] !== value));\n        }\n    });\n}\nexport { createEffect };\n", "import { effectsSymbol } from \"./symbols\";\nimport { createEffect } from \"./create-effect\";\nfunction setEffects(state, cb) {\n    state[effectsSymbol].push(cb);\n}\n/**\n * @function\n * @param {() => void} effect - callback function that runs each time dependencies change\n * @param {unknown[]} [dependencies] - list of dependencies to the effect\n * @return {void}\n */\nconst useEffect = createEffect(setEffects);\nexport { setEffects, useEffect };\n", "import { hook, Hook } from \"./hook\";\nimport { contextEvent } from \"./symbols\";\nimport { setEffects } from \"./use-effect\";\nconst getEmitter = (host) => {\n    if (host instanceof Element)\n        return host;\n    return host.startNode || host.endNode || host.parentNode;\n};\n/**\n * @function\n * @template T\n * @param    {Context<T>} context\n * @return   {T}\n */\nconst useContext = hook(class extends Hook {\n    Context;\n    value;\n    _ranEffect;\n    _unsubscribe;\n    constructor(id, state, _) {\n        super(id, state);\n        this._updater = this._updater.bind(this);\n        this._ranEffect = false;\n        this._unsubscribe = null;\n        setEffects(state, this);\n    }\n    update(Context) {\n        if (this.Context !== Context) {\n            this._subscribe(Context);\n            this.Context = Context;\n        }\n        return this.value;\n    }\n    call() {\n        if (!this._ranEffect) {\n            this._ranEffect = true;\n            if (this._unsubscribe)\n                this._unsubscribe();\n            this._subscribe(this.Context);\n            this.state.update();\n        }\n    }\n    _updater(value) {\n        this.value = value;\n        this.state.update();\n    }\n    _subscribe(Context) {\n        const detail = { Context, callback: this._updater };\n        const emitter = getEmitter(this.state.host);\n        emitter.dispatchEvent(new CustomEvent(contextEvent, {\n            detail, // carrier\n            bubbles: true, // to bubble up in tree\n            cancelable: true, // to be able to cancel\n            composed: true, // to pass ShadowDOM boundaries\n        }));\n        const { unsubscribe = null, value } = detail;\n        this.value = unsubscribe ? value : Context.defaultValue;\n        this._unsubscribe = unsubscribe;\n    }\n    teardown() {\n        if (this._unsubscribe) {\n            this._unsubscribe();\n        }\n    }\n});\nexport { useContext };\n", "import { contextEvent } from \"./symbols\";\nimport { useContext } from \"./use-context\";\nfunction makeContext(component) {\n    return (defaultValue) => {\n        const Context = {\n            Provider: class extends HTMLElement {\n                listeners;\n                _value;\n                constructor() {\n                    super();\n                    this.style.display = \"contents\";\n                    this.listeners = new Set();\n                    this.addEventListener(contextEvent, this);\n                }\n                disconnectedCallback() {\n                    this.removeEventListener(contextEvent, this);\n                }\n                handleEvent(event) {\n                    const { detail } = event;\n                    if (detail.Context === Context) {\n                        detail.value = this.value;\n                        detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);\n                        this.listeners.add(detail.callback);\n                        event.stopPropagation();\n                    }\n                }\n                unsubscribe(callback) {\n                    this.listeners.delete(callback);\n                }\n                set value(value) {\n                    this._value = value;\n                    for (let callback of this.listeners) {\n                        callback(value);\n                    }\n                }\n                get value() {\n                    return this._value;\n                }\n            },\n            Consumer: component(function ({ render }) {\n                const context = useContext(Context);\n                return render(context);\n            }, { useShadowDOM: false }),\n            defaultValue,\n        };\n        return Context;\n    };\n}\nexport { makeContext };\n", "import { hook, Hook } from \"./hook\";\n/**\n * @function\n * @template T\n * @param  {() => T} fn function to memoize\n * @param  {unknown[]} values dependencies to the memoized computation\n * @return {T} The next computed value\n */\nconst useMemo = hook(class extends Hook {\n    value;\n    values;\n    constructor(id, state, fn, values) {\n        super(id, state);\n        this.value = fn();\n        this.values = values;\n    }\n    update(fn, values) {\n        if (this.hasChanged(values)) {\n            this.values = values;\n            this.value = fn();\n        }\n        return this.value;\n    }\n    hasChanged(values = []) {\n        return values.some((value, i) => this.values[i] !== value);\n    }\n});\nexport { useMemo };\n", "import { useMemo } from \"./use-memo\";\n/**\n * @function\n * @template {Function} T\n * @param    {T} fn - callback to memoize\n * @param    {unknown[]} inputs - dependencies to callback memoization\n * @return   {T}\n */\nconst useCallback = (fn, inputs) => useMemo(() => fn, inputs);\nexport { useCallback };\n", "import { layoutEffectsSymbol } from \"./symbols\";\nimport { createEffect } from \"./create-effect\";\nfunction setLayoutEffects(state, cb) {\n    state[layoutEffectsSymbol].push(cb);\n}\n/**\n * @function\n * @param  {Effect} callback effecting callback\n * @param  {unknown[]} [values] dependencies to the effect\n * @return {void}\n */\nconst useLayoutEffect = createEffect(setLayoutEffects);\nexport { useLayoutEffect };\n", "import { hook, Hook } from \"./hook\";\n/**\n * @function\n * @template {*} T\n * @param {T} [initialState] - Optional initial state\n * @return {StateTuple<T>} stateTuple - Tuple of current state and state updater function\n */\nconst useState = hook(class extends Hook {\n    args;\n    constructor(id, state, initialValue) {\n        super(id, state);\n        this.updater = this.updater.bind(this);\n        if (typeof initialValue === \"function\") {\n            const initFn = initialValue;\n            initialValue = initFn();\n        }\n        this.makeArgs(initialValue);\n    }\n    update() {\n        return this.args;\n    }\n    updater(value) {\n        const [previousValue] = this.args;\n        if (typeof value === \"function\") {\n            const updaterFn = value;\n            value = updaterFn(previousValue);\n        }\n        if (Object.is(previousValue, value)) {\n            return;\n        }\n        this.makeArgs(value);\n        this.state.update();\n    }\n    makeArgs(value) {\n        this.args = Object.freeze([value, this.updater]);\n    }\n});\nexport { useState };\n", "import { hook, Hook } from \"./hook\";\n/**\n * Given a reducer function, initial state, and optional state initializer function, returns a tuple of state and dispatch function.\n * @function\n * @template S State\n * @template I Initial State\n * @template A Action\n * @param {Reducer<S, A>} reducer - reducer function to compute the next state given the previous state and the action\n * @param {I} initialState - the initial state of the reducer\n * @param {(init: I) => S} [init=undefined] - Optional initializer function, called on initialState if provided\n * @return {readonly [S, (action: A) => void]}\n */\nconst useReducer = hook(class extends Hook {\n    reducer;\n    currentState;\n    constructor(id, state, _, initialState, init) {\n        super(id, state);\n        this.dispatch = this.dispatch.bind(this);\n        this.currentState =\n            init !== undefined ? init(initialState) : initialState;\n    }\n    update(reducer) {\n        this.reducer = reducer;\n        return [this.currentState, this.dispatch];\n    }\n    dispatch(action) {\n        this.currentState = this.reducer(this.currentState, action);\n        this.state.update();\n    }\n});\nexport { useReducer };\n", "import { hook, Hook } from \"./hook\";\nconst UPPER = /([A-Z])/gu;\nexport const useProperty = hook(class extends Hook {\n    property;\n    eventName;\n    constructor(id, state, property, initialValue) {\n        super(id, state);\n        if (this.state.virtual) {\n            throw new Error(\"Can't be used with virtual components.\");\n        }\n        this.updater = this.updater.bind(this);\n        this.property = property;\n        this.eventName =\n            property.replace(UPPER, \"-$1\").toLowerCase() + \"-changed\";\n        // set the initial value only if it was not already set by the parent\n        if (this.state.host[this.property] != null)\n            return;\n        if (typeof initialValue === \"function\") {\n            const initFn = initialValue;\n            initialValue = initFn();\n        }\n        if (initialValue == null)\n            return;\n        this.updateProp(initialValue);\n    }\n    update(ignored, ignored2) {\n        return [this.state.host[this.property], this.updater];\n    }\n    updater(value) {\n        const previousValue = this.state.host[this.property];\n        if (typeof value === \"function\") {\n            const updaterFn = value;\n            value = updaterFn(previousValue);\n        }\n        if (Object.is(previousValue, value)) {\n            return;\n        }\n        this.updateProp(value);\n    }\n    updateProp(value) {\n        const ev = this.notify(value);\n        if (ev.defaultPrevented)\n            return;\n        this.state.host[this.property] = value;\n    }\n    notify(value) {\n        const ev = new CustomEvent(this.eventName, {\n            detail: { value, path: this.property },\n            cancelable: true,\n        });\n        this.state.host.dispatchEvent(ev);\n        return ev;\n    }\n});\nexport const lift = (setter) => (ev) => {\n    ev.preventDefault();\n    setter(ev.detail.value);\n};\n", "import { useMemo } from \"./use-memo\";\nexport function useRef(initialValue) {\n    return useMemo(() => ({\n        current: initialValue,\n    }), []);\n}\n", "import { makeComponent } from \"./component\";\nimport { makeContext } from \"./create-context\";\nfunction pion({ render }) {\n    const component = makeComponent(render);\n    const createContext = makeContext(component);\n    return { component, createContext };\n}\nexport { pion as default, };\nexport { useCallback } from \"./use-callback\";\nexport { useEffect } from \"./use-effect\";\nexport { useLayoutEffect } from \"./use-layout-effect\";\nexport { useState } from \"./use-state\";\nexport { useReducer } from \"./use-reducer\";\nexport { useMemo } from \"./use-memo\";\nexport { useContext } from \"./use-context\";\nexport { useProperty, lift } from \"./use-property\";\nexport { useRef } from \"./use-ref\";\nexport { hook, Hook } from \"./hook\";\nexport { BaseScheduler } from \"./scheduler\";\nexport { State } from \"./state\";\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Disconnectable, Part} from './lit-html.js';\n\nexport {\n  AttributePart,\n  BooleanAttributePart,\n  ChildPart,\n  ElementPart,\n  EventPart,\n  Part,\n  PropertyPart,\n} from './lit-html.js';\n\nexport interface DirectiveClass {\n  new (part: PartInfo): Directive;\n}\n\n/**\n * This utility type extracts the signature of a directive class's render()\n * method so we can use it for the type of the generated directive function.\n */\nexport type DirectiveParameters<C extends Directive> = Parameters<C['render']>;\n\n/**\n * A generated directive function doesn't evaluate the directive, but just\n * returns a DirectiveResult object that captures the arguments.\n */\nexport interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {\n  /**\n   * This property needs to remain unminified.\n   * @internal\n   */\n  ['_$litDirective$']: C;\n  /** @internal */\n  values: DirectiveParameters<InstanceType<C>>;\n}\n\nexport const PartType = {\n  ATTRIBUTE: 1,\n  CHILD: 2,\n  PROPERTY: 3,\n  BOOLEAN_ATTRIBUTE: 4,\n  EVENT: 5,\n  ELEMENT: 6,\n} as const;\n\nexport type PartType = (typeof PartType)[keyof typeof PartType];\n\nexport interface ChildPartInfo {\n  readonly type: typeof PartType.CHILD;\n}\n\nexport interface AttributePartInfo {\n  readonly type:\n    | typeof PartType.ATTRIBUTE\n    | typeof PartType.PROPERTY\n    | typeof PartType.BOOLEAN_ATTRIBUTE\n    | typeof PartType.EVENT;\n  readonly strings?: ReadonlyArray<string>;\n  readonly name: string;\n  readonly tagName: string;\n}\n\nexport interface ElementPartInfo {\n  readonly type: typeof PartType.ELEMENT;\n}\n\n/**\n * Information about the part a directive is bound to.\n *\n * This is useful for checking that a directive is attached to a valid part,\n * such as with directive that can only be used on attribute bindings.\n */\nexport type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;\n\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport const directive =\n  <C extends DirectiveClass>(c: C) =>\n  (...values: DirectiveParameters<InstanceType<C>>): DirectiveResult<C> => ({\n    // This property needs to remain unminified.\n    ['_$litDirective$']: c,\n    values,\n  });\n\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport abstract class Directive implements Disconnectable {\n  //@internal\n  __part!: Part;\n  //@internal\n  __attributeIndex: number | undefined;\n  //@internal\n  __directive?: Directive;\n\n  //@internal\n  _$parent!: Disconnectable;\n\n  // These will only exist on the AsyncDirective subclass\n  //@internal\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // This property needs to remain unminified.\n  //@internal\n  ['_$notifyDirectiveConnectionChanged']?(isConnected: boolean): void;\n\n  constructor(_partInfo: PartInfo) {}\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  /** @internal */\n  _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    this.__part = part;\n    this._$parent = parent;\n    this.__attributeIndex = attributeIndex;\n  }\n  /** @internal */\n  _$resolve(part: Part, props: Array<unknown>): unknown {\n    return this.update(part, props);\n  }\n\n  abstract render(...props: Array<unknown>): unknown;\n\n  update(_part: Part, props: Array<unknown>): unknown {\n    return this.render(...props);\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  _$LH,\n  Part,\n  DirectiveParent,\n  CompiledTemplateResult,\n  MaybeCompiledTemplateResult,\n  UncompiledTemplateResult,\n} from './lit-html.js';\nimport {\n  DirectiveResult,\n  DirectiveClass,\n  PartInfo,\n  AttributePartInfo,\n} from './directive.js';\ntype Primitive = null | undefined | boolean | number | string | symbol | bigint;\n\nconst {_ChildPart: ChildPart} = _$LH;\n\ntype ChildPart = InstanceType<typeof ChildPart>;\n\nconst ENABLE_SHADYDOM_NOPATCH = true;\n\nconst wrap =\n  ENABLE_SHADYDOM_NOPATCH &&\n  window.ShadyDOM?.inUse &&\n  window.ShadyDOM?.noPatch === true\n    ? window.ShadyDOM!.wrap\n    : (node: Node) => node;\n\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nexport const isPrimitive = (value: unknown): value is Primitive =>\n  value === null || (typeof value != 'object' && typeof value != 'function');\n\nexport const TemplateResultType = {\n  HTML: 1,\n  SVG: 2,\n  MATHML: 3,\n} as const;\n\nexport type TemplateResultType =\n  (typeof TemplateResultType)[keyof typeof TemplateResultType];\n\ntype IsTemplateResult = {\n  (val: unknown): val is MaybeCompiledTemplateResult;\n  <T extends TemplateResultType>(\n    val: unknown,\n    type: T\n  ): val is UncompiledTemplateResult<T>;\n};\n\n/**\n * Tests if a value is a TemplateResult or a CompiledTemplateResult.\n */\nexport const isTemplateResult: IsTemplateResult = (\n  value: unknown,\n  type?: TemplateResultType\n): value is UncompiledTemplateResult =>\n  type === undefined\n    ? // This property needs to remain unminified.\n      (value as UncompiledTemplateResult)?.['_$litType$'] !== undefined\n    : (value as UncompiledTemplateResult)?.['_$litType$'] === type;\n\n/**\n * Tests if a value is a CompiledTemplateResult.\n */\nexport const isCompiledTemplateResult = (\n  value: unknown\n): value is CompiledTemplateResult => {\n  return (value as CompiledTemplateResult)?.['_$litType$']?.h != null;\n};\n\n/**\n * Tests if a value is a DirectiveResult.\n */\nexport const isDirectiveResult = (value: unknown): value is DirectiveResult =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'] !== undefined;\n\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nexport const getDirectiveClass = (value: unknown): DirectiveClass | undefined =>\n  // This property needs to remain unminified.\n  (value as DirectiveResult)?.['_$litDirective$'];\n\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nexport const isSingleExpression = (part: PartInfo) =>\n  (part as AttributePartInfo).strings === undefined;\n\nconst createMarker = () => document.createComment('');\n\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nexport const insertPart = (\n  containerPart: ChildPart,\n  refPart?: ChildPart,\n  part?: ChildPart\n): ChildPart => {\n  const container = wrap(containerPart._$startNode).parentNode!;\n\n  const refNode =\n    refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n\n  if (part === undefined) {\n    const startNode = wrap(container).insertBefore(createMarker(), refNode);\n    const endNode = wrap(container).insertBefore(createMarker(), refNode);\n    part = new ChildPart(\n      startNode,\n      endNode,\n      containerPart,\n      containerPart.options\n    );\n  } else {\n    const endNode = wrap(part._$endNode!).nextSibling;\n    const oldParent = part._$parent;\n    const parentChanged = oldParent !== containerPart;\n    if (parentChanged) {\n      part._$reparentDisconnectables?.(containerPart);\n      // Note that although `_$reparentDisconnectables` updates the part's\n      // `_$parent` reference after unlinking from its current parent, that\n      // method only exists if Disconnectables are present, so we need to\n      // unconditionally set it here\n      part._$parent = containerPart;\n      // Since the _$isConnected getter is somewhat costly, only\n      // read it once we know the subtree has directives that need\n      // to be notified\n      let newConnectionState;\n      if (\n        part._$notifyConnectionChanged !== undefined &&\n        (newConnectionState = containerPart._$isConnected) !==\n          oldParent!._$isConnected\n      ) {\n        part._$notifyConnectionChanged(newConnectionState);\n      }\n    }\n    if (endNode !== refNode || parentChanged) {\n      let start: Node | null = part._$startNode;\n      while (start !== endNode) {\n        const n: Node | null = wrap(start!).nextSibling;\n        wrap(container).insertBefore(start!, refNode);\n        start = n;\n      }\n    }\n  }\n\n  return part;\n};\n\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nexport const setChildPartValue = <T extends ChildPart>(\n  part: T,\n  value: unknown,\n  directiveParent: DirectiveParent = part\n): T => {\n  part._$setValue(value, directiveParent);\n  return part;\n};\n\n// A sentinel value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nexport const setCommittedValue = (part: Part, value: unknown = RESET_VALUE) =>\n  (part._$committedValue = value);\n\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being committed.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nexport const getCommittedValue = (part: ChildPart) => part._$committedValue;\n\n/**\n * Removes a ChildPart from the DOM, including any of its content and markers.\n *\n * Note: The only difference between this and clearPart() is that this also\n * removes the part's start node. This means that the ChildPart must own its\n * start node, ie it must be a marker node specifically for this part and not an\n * anchor from surrounding content.\n *\n * @param part The Part to remove\n */\nexport const removePart = (part: ChildPart) => {\n  part._$clear();\n  part._$startNode.remove();\n};\n\nexport const clearPart = (part: ChildPart) => {\n  part._$clear();\n};\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * Overview:\n *\n * This module is designed to add support for an async `setValue` API and\n * `disconnected` callback to directives with the least impact on the core\n * runtime or payload when that feature is not used.\n *\n * The strategy is to introduce a `AsyncDirective` subclass of\n * `Directive` that climbs the \"parent\" tree in its constructor to note which\n * branches of lit-html's \"logical tree\" of data structures contain such\n * directives and thus need to be crawled when a subtree is being cleared (or\n * manually disconnected) in order to run the `disconnected` callback.\n *\n * The \"nodes\" of the logical tree include Parts, TemplateInstances (for when a\n * TemplateResult is committed to a value of a ChildPart), and Directives; these\n * all implement a common interface called `DisconnectableChild`. Each has a\n * `_$parent` reference which is set during construction in the core code, and a\n * `_$disconnectableChildren` field which is initially undefined.\n *\n * The sparse tree created by means of the `AsyncDirective` constructor\n * crawling up the `_$parent` tree and placing a `_$disconnectableChildren` Set\n * on each parent that includes each child that contains a\n * `AsyncDirective` directly or transitively via its children. In order to\n * notify connection state changes and disconnect (or reconnect) a tree, the\n * `_$notifyConnectionChanged` API is patched onto ChildParts as a directive\n * climbs the parent tree, which is called by the core when clearing a part if\n * it exists. When called, that method iterates over the sparse tree of\n * Set<DisconnectableChildren> built up by AsyncDirectives, and calls\n * `_$notifyDirectiveConnectionChanged` on any directives that are encountered\n * in that tree, running the required callbacks.\n *\n * A given \"logical tree\" of lit-html data-structures might look like this:\n *\n *  ChildPart(N1) _$dC=[D2,T3]\n *   ._directive\n *     AsyncDirective(D2)\n *   ._value // user value was TemplateResult\n *     TemplateInstance(T3) _$dC=[A4,A6,N10,N12]\n *      ._$parts[]\n *        AttributePart(A4) _$dC=[D5]\n *         ._directives[]\n *           AsyncDirective(D5)\n *        AttributePart(A6) _$dC=[D7,D8]\n *         ._directives[]\n *           AsyncDirective(D7)\n *           Directive(D8) _$dC=[D9]\n *            ._directive\n *              AsyncDirective(D9)\n *        ChildPart(N10) _$dC=[D11]\n *         ._directive\n *           AsyncDirective(D11)\n *         ._value\n *           string\n *        ChildPart(N12) _$dC=[D13,N14,N16]\n *         ._directive\n *           AsyncDirective(D13)\n *         ._value // user value was iterable\n *           Array<ChildPart>\n *             ChildPart(N14) _$dC=[D15]\n *              ._value\n *                string\n *             ChildPart(N16) _$dC=[D17,T18]\n *              ._directive\n *                AsyncDirective(D17)\n *              ._value // user value was TemplateResult\n *                TemplateInstance(T18) _$dC=[A19,A21,N25]\n *                 ._$parts[]\n *                   AttributePart(A19) _$dC=[D20]\n *                    ._directives[]\n *                      AsyncDirective(D20)\n *                   AttributePart(A21) _$dC=[22,23]\n *                    ._directives[]\n *                      AsyncDirective(D22)\n *                      Directive(D23) _$dC=[D24]\n *                       ._directive\n *                         AsyncDirective(D24)\n *                   ChildPart(N25) _$dC=[D26]\n *                    ._directive\n *                      AsyncDirective(D26)\n *                    ._value\n *                      string\n *\n * Example 1: The directive in ChildPart(N12) updates and returns `nothing`. The\n * ChildPart will _clear() itself, and so we need to disconnect the \"value\" of\n * the ChildPart (but not its directive). In this case, when `_clear()` calls\n * `_$notifyConnectionChanged()`, we don't iterate all of the\n * _$disconnectableChildren, rather we do a value-specific disconnection: i.e.\n * since the _value was an Array<ChildPart> (because an iterable had been\n * committed), we iterate the array of ChildParts (N14, N16) and run\n * `setConnected` on them (which does recurse down the full tree of\n * `_$disconnectableChildren` below it, and also removes N14 and N16 from N12's\n * `_$disconnectableChildren`). Once the values have been disconnected, we then\n * check whether the ChildPart(N12)'s list of `_$disconnectableChildren` is empty\n * (and would remove it from its parent TemplateInstance(T3) if so), but since\n * it would still contain its directive D13, it stays in the disconnectable\n * tree.\n *\n * Example 2: In the course of Example 1, `setConnected` will reach\n * ChildPart(N16); in this case the entire part is being disconnected, so we\n * simply iterate all of N16's `_$disconnectableChildren` (D17,T18) and\n * recursively run `setConnected` on them. Note that we only remove children\n * from `_$disconnectableChildren` for the top-level values being disconnected\n * on a clear; doing this bookkeeping lower in the tree is wasteful since it's\n * all being thrown away.\n *\n * Example 3: If the LitElement containing the entire tree above becomes\n * disconnected, it will run `childPart.setConnected()` (which calls\n * `childPart._$notifyConnectionChanged()` if it exists); in this case, we\n * recursively run `setConnected()` over the entire tree, without removing any\n * children from `_$disconnectableChildren`, since this tree is required to\n * re-connect the tree, which does the same operation, simply passing\n * `isConnected: true` down the tree, signaling which callback to run.\n */\n\nimport {AttributePart, ChildPart, Disconnectable, Part} from './lit-html.js';\nimport {isSingleExpression} from './directive-helpers.js';\nimport {Directive, PartInfo, PartType} from './directive.js';\nexport * from './directive.js';\n\nconst DEV_MODE = true;\n\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (\n  parent: Disconnectable,\n  isConnected: boolean\n): boolean => {\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (obj as AsyncDirective)['_$notifyDirectiveConnectionChanged']?.(\n      isConnected,\n      false\n    );\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj: Disconnectable) => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren!;\n    children.delete(obj);\n    obj = parent;\n  } while (children?.size === 0);\n};\n\nconst addDisconnectableToParent = (obj: Disconnectable) => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; (parent = obj._$parent); obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(this: ChildPart, newParent: Disconnectable) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(\n  this: ChildPart,\n  isConnected: boolean,\n  isClearingValue = false,\n  fromPartIndex = 0\n) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value as Disconnectable, false);\n      removeDisconnectableFromParent(value as Disconnectable);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj: Disconnectable) => {\n  if ((obj as ChildPart).type == PartType.CHILD) {\n    (obj as ChildPart)._$notifyConnectionChanged ??=\n      notifyChildPartConnectedChanged;\n    (obj as ChildPart)._$reparentDisconnectables ??= reparentDisconnectables;\n  }\n};\n\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport abstract class AsyncDirective extends Directive {\n  // As opposed to other Disconnectables, AsyncDirectives always get notified\n  // when the RootPart connection changes, so the public `isConnected`\n  // is a locally stored variable initialized via its part's getter and synced\n  // via `_$notifyDirectiveConnectionChanged`. This is cheaper than using\n  // the _$isConnected getter, which has to look back up the tree each time.\n  /**\n   * The connection state for this Directive.\n   */\n  isConnected!: boolean;\n\n  // @internal\n  override _$disconnectableChildren?: Set<Disconnectable> = undefined;\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  override _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  override ['_$notifyDirectiveConnectionChanged'](\n    isConnected: boolean,\n    isClearingDirective = true\n  ) {\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        this.reconnected?.();\n      } else {\n        this.disconnected?.();\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value: unknown) {\n    if (isSingleExpression(this.__part as unknown as PartInfo)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...(this.__part._$committedValue as Array<unknown>)];\n      newValues[this.__attributeIndex!] = value;\n      (this.__part as AttributePart)._$setValue(newValues, this, 0);\n    }\n  }\n\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  protected disconnected() {}\n  protected reconnected() {}\n}\n", "import { directive, } from \"lit-html/directive.js\";\nimport { noChange } from \"lit-html\";\nimport { AsyncDirective } from \"lit-html/async-directive.js\";\nimport { BaseScheduler } from \"./scheduler\";\nconst includes = Array.prototype.includes;\nconst partToScheduler = new WeakMap();\nconst schedulerToPart = new WeakMap();\nclass Scheduler extends BaseScheduler {\n    args;\n    setValue;\n    constructor(renderer, part, setValue) {\n        super(renderer, part);\n        this.state.virtual = true;\n        this.setValue = setValue;\n    }\n    render() {\n        return this.state.run(() => this.renderer.apply(this.host, this.args));\n    }\n    commit(result) {\n        this.setValue(result);\n    }\n    teardown() {\n        super.teardown();\n        let part = schedulerToPart.get(this);\n        partToScheduler.delete(part);\n    }\n}\nfunction makeVirtual() {\n    function virtual(renderer) {\n        class VirtualDirective extends AsyncDirective {\n            cont;\n            constructor(partInfo) {\n                super(partInfo);\n                this.cont = undefined;\n            }\n            update(part, args) {\n                this.cont = partToScheduler.get(part);\n                if (!this.cont || this.cont.renderer !== renderer) {\n                    this.cont = new Scheduler(renderer, part, (r) => {\n                        this.setValue(r);\n                    });\n                    partToScheduler.set(part, this.cont);\n                    schedulerToPart.set(this.cont, part);\n                    teardownOnRemove(this.cont, part);\n                }\n                this.cont.args = args;\n                this.cont.update();\n                return this.render(...args);\n            }\n            render(...args) {\n                return noChange;\n            }\n        }\n        return directive(VirtualDirective);\n    }\n    return virtual;\n}\nfunction teardownOnRemove(cont, part, node = part.startNode) {\n    let frag = node.parentNode;\n    let mo = new MutationObserver((mutations) => {\n        for (let mutation of mutations) {\n            if (includes.call(mutation.removedNodes, node)) {\n                mo.disconnect();\n                if (node.parentNode instanceof ShadowRoot) {\n                    teardownOnRemove(cont, part);\n                }\n                else {\n                    cont.teardown();\n                }\n                break;\n            }\n            else if (includes.call(mutation.addedNodes, node.nextSibling)) {\n                mo.disconnect();\n                teardownOnRemove(cont, part, node.nextSibling || undefined);\n                break;\n            }\n        }\n    });\n    mo.observe(frag, { childList: true });\n}\nexport { makeVirtual };\n", "import { html, render } from \"lit-html\";\nimport pion from \"./core\";\nimport { makeVirtual } from \"./virtual\";\nconst { component, createContext } = pion({ render });\nconst virtual = makeVirtual();\nexport { component, createContext, virtual, html, render };\n"],
  "mappings": "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",
  "names": ["hook", "render", "Scheduler", "component", "Element", "Hook", "hook", "setEffects", "component", "render", "render", "component", "createContext", "virtual"]
}
