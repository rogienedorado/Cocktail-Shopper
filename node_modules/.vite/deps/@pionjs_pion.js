import {
  _$LH,
  html,
  noChange,
  render
} from "./chunk-BMGFCGDO.js";

// node_modules/@pionjs/pion/lib/interface.js
var current;
var currentId = 0;
function setCurrent(state) {
  current = state;
}
function clear() {
  current = null;
  currentId = 0;
}
function notify() {
  return currentId++;
}

// node_modules/@pionjs/pion/lib/symbols.js
var phaseSymbol = Symbol("haunted.phase");
var hookSymbol = Symbol("haunted.hook");
var updateSymbol = Symbol("haunted.update");
var commitSymbol = Symbol("haunted.commit");
var effectsSymbol = Symbol("haunted.effects");
var layoutEffectsSymbol = Symbol("haunted.layoutEffects");
var contextEvent = "haunted.context";

// node_modules/@pionjs/pion/lib/state.js
var State = class {
  update;
  host;
  virtual;
  [hookSymbol];
  [effectsSymbol];
  [layoutEffectsSymbol];
  constructor(update, host) {
    this.update = update;
    this.host = host;
    this[hookSymbol] = /* @__PURE__ */ new Map();
    this[effectsSymbol] = [];
    this[layoutEffectsSymbol] = [];
  }
  run(cb) {
    setCurrent(this);
    let res = cb();
    clear();
    return res;
  }
  _runEffects(phase) {
    let effects = this[phase];
    setCurrent(this);
    for (let effect of effects) {
      effect.call(this);
    }
    clear();
  }
  runEffects() {
    this._runEffects(effectsSymbol);
  }
  runLayoutEffects() {
    this._runEffects(layoutEffectsSymbol);
  }
  teardown() {
    let hooks = this[hookSymbol];
    hooks.forEach((hook2) => {
      if (typeof hook2.teardown === "function") {
        hook2.teardown(true);
      }
    });
  }
};

// node_modules/@pionjs/pion/lib/scheduler.js
var defer = Promise.resolve().then.bind(Promise.resolve());
function runner() {
  let tasks = [];
  let id;
  function runTasks() {
    id = null;
    let t = tasks;
    tasks = [];
    for (var i = 0, len = t.length; i < len; i++) {
      t[i]();
    }
  }
  return function(task) {
    tasks.push(task);
    if (id == null) {
      id = defer(runTasks);
    }
  };
}
var read = runner();
var write = runner();
var BaseScheduler = class {
  renderer;
  host;
  state;
  [phaseSymbol];
  _updateQueued;
  _active;
  constructor(renderer, host) {
    this.renderer = renderer;
    this.host = host;
    this.state = new State(this.update.bind(this), host);
    this[phaseSymbol] = null;
    this._updateQueued = false;
    this._active = true;
  }
  update() {
    if (!this._active)
      return;
    if (this._updateQueued)
      return;
    read(() => {
      let result = this.handlePhase(updateSymbol);
      write(() => {
        this.handlePhase(commitSymbol, result);
        write(() => {
          this.handlePhase(effectsSymbol);
        });
      });
      this._updateQueued = false;
    });
    this._updateQueued = true;
  }
  handlePhase(phase, arg) {
    this[phaseSymbol] = phase;
    switch (phase) {
      case commitSymbol:
        this.commit(arg);
        this.runEffects(layoutEffectsSymbol);
        return;
      case updateSymbol:
        return this.render();
      case effectsSymbol:
        return this.runEffects(effectsSymbol);
    }
  }
  render() {
    return this.state.run(() => this.renderer.call(this.host, this.host));
  }
  runEffects(phase) {
    this.state._runEffects(phase);
  }
  teardown() {
    this.state.teardown();
  }
  pause() {
    this._active = false;
  }
  resume() {
    this._active = true;
  }
};

// node_modules/@pionjs/pion/lib/util.js
var sheet = (...styles) => {
  const cs = new CSSStyleSheet();
  cs.replaceSync(styles.join(""));
  return cs;
};
var sheets = (styleSheets) => styleSheets?.map((style) => {
  if (typeof style === "string")
    return sheet(style);
  return style;
});
var tagged = (strings, ...values) => strings.flatMap((s, i) => [s, values[i] || ""]).join("");
var css = tagged;

// node_modules/@pionjs/pion/lib/component.js
var toCamelCase = (val = "") => val.replace(/-+([a-z])?/g, (_, char) => char ? char.toUpperCase() : "");
function makeComponent(render2) {
  class Scheduler2 extends BaseScheduler {
    frag;
    renderResult;
    constructor(renderer, frag, host) {
      super(renderer, host || frag);
      this.frag = frag;
    }
    commit(result) {
      this.renderResult = render2(result, this.frag);
    }
  }
  function component2(renderer, baseElementOrOptions, options) {
    const BaseElement = (options || baseElementOrOptions || {}).baseElement || HTMLElement;
    const { observedAttributes = [], useShadowDOM = true, shadowRootInit = {}, styleSheets: _styleSheets } = options || baseElementOrOptions || {};
    const styleSheets = sheets(renderer.styleSheets || _styleSheets);
    class Element2 extends BaseElement {
      _scheduler;
      static get observedAttributes() {
        return renderer.observedAttributes || observedAttributes || [];
      }
      constructor() {
        super();
        if (useShadowDOM === false) {
          this._scheduler = new Scheduler2(renderer, this);
        } else {
          const shadowRoot = this.attachShadow({
            mode: "open",
            ...shadowRootInit
          });
          if (styleSheets)
            shadowRoot.adoptedStyleSheets = styleSheets;
          this._scheduler = new Scheduler2(renderer, shadowRoot, this);
        }
      }
      connectedCallback() {
        this._scheduler.resume();
        this._scheduler.update();
        this._scheduler.renderResult?.setConnected(true);
      }
      disconnectedCallback() {
        this._scheduler.pause();
        this._scheduler.teardown();
        this._scheduler.renderResult?.setConnected(false);
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue) {
          return;
        }
        let val = newValue === "" ? true : newValue;
        Reflect.set(this, toCamelCase(name), val);
      }
    }
    function reflectiveProp(initialValue) {
      let value = initialValue;
      let isSetup = false;
      return Object.freeze({
        enumerable: true,
        configurable: true,
        get() {
          return value;
        },
        set(newValue) {
          if (isSetup && value === newValue)
            return;
          isSetup = true;
          value = newValue;
          if (this._scheduler) {
            this._scheduler.update();
          }
        }
      });
    }
    const proto = new Proxy(BaseElement.prototype, {
      getPrototypeOf(target) {
        return target;
      },
      set(target, key, value, receiver) {
        let desc;
        if (key in target) {
          desc = Object.getOwnPropertyDescriptor(target, key);
          if (desc && desc.set) {
            desc.set.call(receiver, value);
            return true;
          }
          Reflect.set(target, key, value, receiver);
          return true;
        }
        if (typeof key === "symbol" || key[0] === "_") {
          desc = {
            enumerable: true,
            configurable: true,
            writable: true,
            value
          };
        } else {
          desc = reflectiveProp(value);
        }
        Object.defineProperty(receiver, key, desc);
        if (desc.set) {
          desc.set.call(receiver, value);
        }
        return true;
      }
    });
    Object.setPrototypeOf(Element2.prototype, proto);
    return Element2;
  }
  return component2;
}

// node_modules/@pionjs/pion/lib/hook.js
var Hook = class {
  id;
  state;
  constructor(id, state) {
    this.id = id;
    this.state = state;
  }
};
function use(Hook2, ...args) {
  let id = notify();
  let hooks = current[hookSymbol];
  let hook2 = hooks.get(id);
  if (!hook2) {
    hook2 = new Hook2(id, current, ...args);
    hooks.set(id, hook2);
  }
  return hook2.update(...args);
}
function hook(Hook2) {
  return use.bind(null, Hook2);
}

// node_modules/@pionjs/pion/lib/create-effect.js
function createEffect(setEffects2) {
  return hook(class extends Hook {
    callback;
    lastValues;
    values;
    _teardown;
    constructor(id, state, ignored1, ignored2) {
      super(id, state);
      setEffects2(state, this);
    }
    update(callback, values) {
      this.callback = callback;
      this.values = values;
    }
    call() {
      const hasChanged = !this.values || this.hasChanged();
      this.lastValues = this.values;
      if (hasChanged) {
        this.run();
      }
    }
    run() {
      this.teardown();
      this._teardown = this.callback.call(this.state);
    }
    teardown(disconnected) {
      if (typeof this._teardown === "function") {
        this._teardown();
        this._teardown = void 0;
      }
      if (disconnected) {
        this.lastValues = this.values = void 0;
      }
    }
    hasChanged() {
      return !this.lastValues || this.values.some((value, i) => this.lastValues[i] !== value);
    }
  });
}

// node_modules/@pionjs/pion/lib/use-effect.js
function setEffects(state, cb) {
  state[effectsSymbol].push(cb);
}
var useEffect = createEffect(setEffects);

// node_modules/@pionjs/pion/lib/use-context.js
var getEmitter = (host) => {
  if (host instanceof Element)
    return host;
  return host.startNode || host.endNode || host.parentNode;
};
var useContext = hook(class extends Hook {
  Context;
  value;
  _ranEffect;
  _unsubscribe;
  constructor(id, state, _) {
    super(id, state);
    this._updater = this._updater.bind(this);
    this._ranEffect = false;
    this._unsubscribe = null;
    setEffects(state, this);
  }
  update(Context) {
    if (this.Context !== Context) {
      this._subscribe(Context);
      this.Context = Context;
    }
    return this.value;
  }
  call() {
    if (!this._ranEffect) {
      this._ranEffect = true;
      if (this._unsubscribe)
        this._unsubscribe();
      this._subscribe(this.Context);
      this.state.update();
    }
  }
  _updater(value) {
    this.value = value;
    this.state.update();
  }
  _subscribe(Context) {
    const detail = { Context, callback: this._updater };
    const emitter = getEmitter(this.state.host);
    emitter.dispatchEvent(new CustomEvent(contextEvent, {
      detail,
      // carrier
      bubbles: true,
      // to bubble up in tree
      cancelable: true,
      // to be able to cancel
      composed: true
      // to pass ShadowDOM boundaries
    }));
    const { unsubscribe = null, value } = detail;
    this.value = unsubscribe ? value : Context.defaultValue;
    this._unsubscribe = unsubscribe;
  }
  teardown() {
    if (this._unsubscribe) {
      this._unsubscribe();
    }
  }
});

// node_modules/@pionjs/pion/lib/create-context.js
function makeContext(component2) {
  return (defaultValue) => {
    const Context = {
      Provider: class extends HTMLElement {
        listeners;
        _value;
        constructor() {
          super();
          this.style.display = "contents";
          this.listeners = /* @__PURE__ */ new Set();
          this.addEventListener(contextEvent, this);
        }
        disconnectedCallback() {
          this.removeEventListener(contextEvent, this);
        }
        handleEvent(event) {
          const { detail } = event;
          if (detail.Context === Context) {
            detail.value = this.value;
            detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);
            this.listeners.add(detail.callback);
            event.stopPropagation();
          }
        }
        unsubscribe(callback) {
          this.listeners.delete(callback);
        }
        set value(value) {
          this._value = value;
          for (let callback of this.listeners) {
            callback(value);
          }
        }
        get value() {
          return this._value;
        }
      },
      Consumer: component2(function({ render: render2 }) {
        const context = useContext(Context);
        return render2(context);
      }, { useShadowDOM: false }),
      defaultValue
    };
    return Context;
  };
}

// node_modules/@pionjs/pion/lib/use-memo.js
var useMemo = hook(class extends Hook {
  value;
  values;
  constructor(id, state, fn, values) {
    super(id, state);
    this.value = fn();
    this.values = values;
  }
  update(fn, values) {
    if (this.hasChanged(values)) {
      this.values = values;
      this.value = fn();
    }
    return this.value;
  }
  hasChanged(values = []) {
    return values.some((value, i) => this.values[i] !== value);
  }
});

// node_modules/@pionjs/pion/lib/use-callback.js
var useCallback = (fn, inputs) => useMemo(() => fn, inputs);

// node_modules/@pionjs/pion/lib/use-layout-effect.js
function setLayoutEffects(state, cb) {
  state[layoutEffectsSymbol].push(cb);
}
var useLayoutEffect = createEffect(setLayoutEffects);

// node_modules/@pionjs/pion/lib/use-state.js
var useState = hook(class extends Hook {
  args;
  constructor(id, state, initialValue) {
    super(id, state);
    this.updater = this.updater.bind(this);
    if (typeof initialValue === "function") {
      const initFn = initialValue;
      initialValue = initFn();
    }
    this.makeArgs(initialValue);
  }
  update() {
    return this.args;
  }
  updater(value) {
    const [previousValue] = this.args;
    if (typeof value === "function") {
      const updaterFn = value;
      value = updaterFn(previousValue);
    }
    if (Object.is(previousValue, value)) {
      return;
    }
    this.makeArgs(value);
    this.state.update();
  }
  makeArgs(value) {
    this.args = Object.freeze([value, this.updater]);
  }
});

// node_modules/@pionjs/pion/lib/use-reducer.js
var useReducer = hook(class extends Hook {
  reducer;
  currentState;
  constructor(id, state, _, initialState, init) {
    super(id, state);
    this.dispatch = this.dispatch.bind(this);
    this.currentState = init !== void 0 ? init(initialState) : initialState;
  }
  update(reducer) {
    this.reducer = reducer;
    return [this.currentState, this.dispatch];
  }
  dispatch(action) {
    this.currentState = this.reducer(this.currentState, action);
    this.state.update();
  }
});

// node_modules/@pionjs/pion/lib/use-property.js
var UPPER = /([A-Z])/gu;
var useProperty = hook(class extends Hook {
  property;
  eventName;
  constructor(id, state, property, initialValue) {
    super(id, state);
    if (this.state.virtual) {
      throw new Error("Can't be used with virtual components.");
    }
    this.updater = this.updater.bind(this);
    this.property = property;
    this.eventName = property.replace(UPPER, "-$1").toLowerCase() + "-changed";
    if (this.state.host[this.property] != null)
      return;
    if (typeof initialValue === "function") {
      const initFn = initialValue;
      initialValue = initFn();
    }
    if (initialValue == null)
      return;
    this.updateProp(initialValue);
  }
  update(ignored, ignored2) {
    return [this.state.host[this.property], this.updater];
  }
  updater(value) {
    const previousValue = this.state.host[this.property];
    if (typeof value === "function") {
      const updaterFn = value;
      value = updaterFn(previousValue);
    }
    if (Object.is(previousValue, value)) {
      return;
    }
    this.updateProp(value);
  }
  updateProp(value) {
    const ev = this.notify(value);
    if (ev.defaultPrevented)
      return;
    this.state.host[this.property] = value;
  }
  notify(value) {
    const ev = new CustomEvent(this.eventName, {
      detail: { value, path: this.property },
      cancelable: true
    });
    this.state.host.dispatchEvent(ev);
    return ev;
  }
});
var lift = (setter) => (ev) => {
  ev.preventDefault();
  setter(ev.detail.value);
};

// node_modules/@pionjs/pion/lib/use-ref.js
function useRef(initialValue) {
  return useMemo(() => ({
    current: initialValue
  }), []);
}

// node_modules/@pionjs/pion/lib/core.js
function pion({ render: render2 }) {
  const component2 = makeComponent(render2);
  const createContext2 = makeContext(component2);
  return { component: component2, createContext: createContext2 };
}

// node_modules/lit-html/development/directive.js
var PartType = {
  ATTRIBUTE: 1,
  CHILD: 2,
  PROPERTY: 3,
  BOOLEAN_ATTRIBUTE: 4,
  EVENT: 5,
  ELEMENT: 6
};
var directive = (c) => (...values) => ({
  // This property needs to remain unminified.
  ["_$litDirective$"]: c,
  values
});
var Directive = class {
  constructor(_partInfo) {
  }
  // See comment in Disconnectable interface for why this is a getter
  get _$isConnected() {
    return this._$parent._$isConnected;
  }
  /** @internal */
  _$initialize(part, parent, attributeIndex) {
    this.__part = part;
    this._$parent = parent;
    this.__attributeIndex = attributeIndex;
  }
  /** @internal */
  _$resolve(part, props) {
    return this.update(part, props);
  }
  update(_part, props) {
    return this.render(...props);
  }
};

// node_modules/lit-html/development/directive-helpers.js
var { _ChildPart: ChildPart } = _$LH;
var ENABLE_SHADYDOM_NOPATCH = true;
var wrap = ENABLE_SHADYDOM_NOPATCH && window.ShadyDOM?.inUse && window.ShadyDOM?.noPatch === true ? window.ShadyDOM.wrap : (node) => node;
var isSingleExpression = (part) => part.strings === void 0;

// node_modules/lit-html/development/async-directive.js
var DEV_MODE = true;
var notifyChildrenConnectedChanged = (parent, isConnected) => {
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    obj["_$notifyDirectiveConnectionChanged"]?.(isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
var removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while (children?.size === 0);
};
var addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i = fromPartIndex; i < value.length; i++) {
        notifyChildrenConnectedChanged(value[i], false);
        removeDisconnectableFromParent(value[i]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
var installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ??= notifyChildPartConnectedChanged;
    obj._$reparentDisconnectables ??= reparentDisconnectables;
  }
};
var AsyncDirective = class extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        this.reconnected?.();
      } else {
        this.disconnected?.();
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (DEV_MODE && this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/@pionjs/pion/lib/virtual.js
var includes = Array.prototype.includes;
var partToScheduler = /* @__PURE__ */ new WeakMap();
var schedulerToPart = /* @__PURE__ */ new WeakMap();
var Scheduler = class extends BaseScheduler {
  args;
  setValue;
  constructor(renderer, part, setValue) {
    super(renderer, part);
    this.state.virtual = true;
    this.setValue = setValue;
  }
  render() {
    return this.state.run(() => this.renderer.apply(this.host, this.args));
  }
  commit(result) {
    this.setValue(result);
  }
  teardown() {
    super.teardown();
    let part = schedulerToPart.get(this);
    partToScheduler.delete(part);
  }
};
function makeVirtual() {
  function virtual2(renderer) {
    class VirtualDirective extends AsyncDirective {
      cont;
      constructor(partInfo) {
        super(partInfo);
        this.cont = void 0;
      }
      update(part, args) {
        this.cont = partToScheduler.get(part);
        if (!this.cont || this.cont.renderer !== renderer) {
          this.cont = new Scheduler(renderer, part, (r) => {
            this.setValue(r);
          });
          partToScheduler.set(part, this.cont);
          schedulerToPart.set(this.cont, part);
          teardownOnRemove(this.cont, part);
        }
        this.cont.args = args;
        this.cont.update();
        return this.render(...args);
      }
      render(...args) {
        return noChange;
      }
    }
    return directive(VirtualDirective);
  }
  return virtual2;
}
function teardownOnRemove(cont, part, node = part.startNode) {
  let frag = node.parentNode;
  let mo = new MutationObserver((mutations) => {
    for (let mutation of mutations) {
      if (includes.call(mutation.removedNodes, node)) {
        mo.disconnect();
        if (node.parentNode instanceof ShadowRoot) {
          teardownOnRemove(cont, part);
        } else {
          cont.teardown();
        }
        break;
      } else if (includes.call(mutation.addedNodes, node.nextSibling)) {
        mo.disconnect();
        teardownOnRemove(cont, part, node.nextSibling || void 0);
        break;
      }
    }
  });
  mo.observe(frag, { childList: true });
}

// node_modules/@pionjs/pion/lib/lit-haunted.js
var { component, createContext } = pion({ render });
var virtual = makeVirtual();
export {
  BaseScheduler,
  Hook,
  State,
  component,
  createContext,
  css,
  pion as default,
  hook,
  html,
  lift,
  render,
  sheet,
  sheets,
  tagged,
  useCallback,
  useContext,
  useEffect,
  useLayoutEffect,
  useMemo,
  useProperty,
  useReducer,
  useRef,
  useState,
  virtual
};
/*! Bundled license information:

lit-html/development/directive.js:
lit-html/development/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@pionjs_pion.js.map
